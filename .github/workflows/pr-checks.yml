name: PR Checks

on:
  pull_request_target:
    branches: 
      - main
      - '*.*.0'
    paths:
      - 'policies/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  pr-checks:
    name: Build, Test & Lint
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      RUN_FORMAT: true
      RUN_IMPORTS: true
      RUN_VET: true
      RUN_STATICCHECK: true
      RUN_GOVULNCHECK: true
      RUN_BUILD: true
      RUN_TESTS: true
      RUN_POLICY_VALIDATION: true

    steps:
      # ------------------------------------------------------------
      # Checkout
      # ------------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      # ------------------------------------------------------------
      # Setup Go
      # ------------------------------------------------------------
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.3"
          cache: false

      # ------------------------------------------------------------
      # Install additional tools
      # -----------------------------------------------------------
      - name: Install formatting tools
        run: |
          go install golang.org/x/tools/cmd/goimports@latest
          go install honnef.co/go/tools/cmd/staticcheck@latest
          go install golang.org/x/vuln/cmd/govulncheck@latest

      # ------------------------------------------------------------
      # Find changed policies
      # ------------------------------------------------------------
      - name: Find changed policies
        id: changed-policies
        run: |
          # Get list of changed files
          if [[ "${{ github.event_name }}" == "pull_request_target" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          fi

          # Find changed policy modules (directories with go.mod)
          CHANGED_POLICIES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" | \
            grep '^policies/' | \
            while read -r file; do
              dir=$(dirname "$file")
              while [[ "$dir" != "policies" && "$dir" != "." ]]; do
                if [[ -f "$dir/go.mod" ]]; then
                  echo "$dir" | sed 's|^policies/||'
                  break
                fi
                dir=$(dirname "$dir")
              done
            done | sort -u || true)

          if [[ -z "$CHANGED_POLICIES" ]]; then
            echo "No policy changes detected"
            echo "policies=" >> "$GITHUB_OUTPUT"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          else
            echo "Changed policies: $CHANGED_POLICIES"
            echo "policies<<EOF" >> "$GITHUB_OUTPUT"
            echo "$CHANGED_POLICIES" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
          fi

      # ------------------------------------------------------------
      # Format check
      # ------------------------------------------------------------
      - name: Check Go formatting
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_FORMAT == 'true'
        run: |
          echo "Checking Go formatting..."
          
          # Check if gofmt would make any changes
          UNFORMATTED=$(find policies/ -name "*.go" -exec gofmt -l {} +)
          
          if [[ -n "$UNFORMATTED" ]]; then
            echo "‚ùå The following files are not properly formatted:" >> errors.log
            echo "$UNFORMATTED" >> errors.log
            echo "" >> errors.log
            echo "Run 'go fmt ./...' to fix formatting issues." >> errors.log
            echo "" >> errors.log
            exit 1
          fi
          
          echo "‚úÖ All Go files are properly formatted"

      # ------------------------------------------------------------
      # Import check
      # ------------------------------------------------------------
      - name: Check Go imports
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_IMPORTS == 'true'
        run: |
          echo "Checking Go imports..."
          
          # Check if goimports would make any changes
          UNFORMATTED=$(find policies/ -name "*.go" -exec goimports -l {} +)
          
          if [[ -n "$UNFORMATTED" ]]; then
            echo "‚ùå The following files have import issues:" >> errors.log
            echo "$UNFORMATTED" >> errors.log
            echo "" >> errors.log
            echo "Run 'goimports -w .' to fix import issues." >> errors.log
            echo "" >> errors.log
            exit 1
          fi
          
          echo "‚úÖ All Go imports are properly formatted"

      # ------------------------------------------------------------
      # Vet check
      # ------------------------------------------------------------
      - name: Run go vet
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_VET == 'true'
        run: |
          echo "Running go vet on changed policies..."
          
          while IFS= read -r policy; do
            [[ -z "$policy" ]] && continue
            
            echo "Checking policy: $policy"
            if output=$(cd "policies/$policy" && go vet ./... 2>&1); then
              echo "‚úÖ go vet passed for policy: $policy"
            else
              echo "‚ùå go vet failed for policy: $policy" >> errors.log
              echo "$output" >> errors.log
              echo "" >> errors.log
            fi
          done <<< "${{ steps.changed-policies.outputs.policies }}"

      # ------------------------------------------------------------
      # Static check
      # ------------------------------------------------------------
      - name: Run staticcheck
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_STATICCHECK == 'true'
        run: |
          echo "Running staticcheck on changed policies..."
          
          while IFS= read -r policy; do
            [[ -z "$policy" ]] && continue
            
            echo "Checking policy: $policy"
            if output=$(cd "policies/$policy" && staticcheck ./... 2>&1); then
              echo "‚úÖ staticcheck passed for policy: $policy"
            else
              echo "‚ùå staticcheck failed for policy: $policy" >> errors.log
              echo "üîç STATICCHECK ERRORS:" >> errors.log
              echo "$output" >> errors.log
              echo "" >> errors.log
            fi
          done <<< "${{ steps.changed-policies.outputs.policies }}"

      # ------------------------------------------------------------
      # Vulnerability check
      # ------------------------------------------------------------
      - name: Run govulncheck
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_GOVULNCHECK == 'true'
        run: |
          echo "==============================================="
          echo "üîç VULNERABILITY CHECK - DETAILED LOGGING"
          echo "==============================================="
          
          echo "üìã Environment Information:"
          echo "Go version: $(go version)"
          echo "Govulncheck version: $(govulncheck -version 2>&1 || echo 'Failed to get version')"
          echo "GOROOT: $(go env GOROOT)"
          echo "GOPATH: $(go env GOPATH)"
          echo "PWD: $(pwd)"
          echo "Current user: $(whoami)"
          echo ""
          
          echo "üìÅ Changed policies to check:"
          echo "${{ steps.changed-policies.outputs.policies }}"
          echo ""
          
          # Ensure govulncheck is in PATH
          export PATH="$PATH:$(go env GOPATH)/bin"
          echo "Updated PATH: $PATH"
          echo ""
          
          # Store the root directory to ensure we can always get back
          ROOT_DIR=$(pwd)
          echo "üìÅ Root directory: $ROOT_DIR"
          echo ""
          
          while IFS= read -r policy; do
            [[ -z "$policy" ]] && continue
            
            # Always start from root directory
            cd "$ROOT_DIR"
            
            echo "üîÑ ===== CHECKING POLICY: $policy ====="
            echo "Policy directory: policies/$policy"
            
            # Check if directory exists
            if [[ ! -d "policies/$policy" ]]; then
              echo "‚ùå ERROR: Directory policies/$policy does not exist"
              ls -la policies/ || echo "Failed to list policies directory"
              continue
            fi
            
            # Check go.mod
            if [[ -f "policies/$policy/go.mod" ]]; then
              echo "üìÑ Go.mod content:"
              cat "policies/$policy/go.mod"
              echo ""
              GO_MOD_VERSION=$(grep '^go ' "policies/$policy/go.mod" | awk '{print $2}' || echo "unknown")
              echo "üìå Go version in go.mod: $GO_MOD_VERSION"
            else
              echo "‚ö†Ô∏è  No go.mod found in policies/$policy"
            fi
            echo ""
            
            # Change to policy directory using absolute path
            POLICY_DIR="$ROOT_DIR/policies/$policy"
            echo "üìÇ Changing to directory: $POLICY_DIR"
            cd "$POLICY_DIR" || {
              echo "‚ùå ERROR: Failed to cd to $POLICY_DIR"
              continue
            }
            
            echo "üìç Current working directory: $(pwd)"
            echo "üìÅ Directory contents:"
            ls -la
            echo ""
            
            # Run govulncheck with maximum verbosity
            echo "üîç Running govulncheck command:"
            echo "govulncheck -show verbose ./..."
            echo ""
            
            echo "üìä GOVULNCHECK OUTPUT START:"
            echo "----------------------------------------"
            
            # Capture both stdout and stderr, and exit code
            set +e  # Don't exit on error
            output=$(govulncheck -show verbose ./... 2>&1)
            exit_code=$?
            set -e  # Re-enable exit on error
            
            echo "$output"
            echo "----------------------------------------"
            echo "üìä GOVULNCHECK OUTPUT END"
            echo ""
            echo "üìà Exit code: $exit_code"
            echo "üìà Exit code meaning:"
            case $exit_code in
              0) echo "  0 = Success, no vulnerabilities found" ;;
              1) echo "  1 = Error occurred during execution" ;;
              3) echo "  3 = Vulnerabilities found in your code" ;;
              *) echo "  $exit_code = Unknown exit code" ;;
            esac
            echo ""
            
            if [[ $exit_code -eq 0 ]]; then
              echo "‚úÖ govulncheck passed for policy: $policy"
            elif [[ $exit_code -eq 3 ]]; then
              echo "‚ùå Vulnerabilities found in policy: $policy" | tee -a "$ROOT_DIR/errors.log"
              
              # Extract and format vulnerability summary
              vuln_summary=$(echo "$output" | grep -A2 "Vulnerability #" | grep -E "^\s*(GO-[0-9]+-[0-9]+|More info:)" | head -20)
              vuln_count=$(echo "$output" | grep -c "Vulnerability #" || echo "0")
              
              echo "üî¥ $vuln_count vulnerabilities found (Go standard library)" >> "$ROOT_DIR/errors.log"
              echo "üîß Fix: Upgrade to Go 1.25.5 or later" >> "$ROOT_DIR/errors.log"
              echo "üìã Vulnerabilities:" >> "$ROOT_DIR/errors.log"
              echo "$vuln_summary" | sed 's/^/  /' >> "$ROOT_DIR/errors.log"
              echo "" >> "$ROOT_DIR/errors.log"
            else
              echo "‚ùå govulncheck failed for policy: $policy (exit code: $exit_code)" | tee -a "$ROOT_DIR/errors.log"
              echo "Policy: $policy" >> "$ROOT_DIR/errors.log"
              echo "Exit code: $exit_code" >> "$ROOT_DIR/errors.log"
              echo "Error output:" >> "$ROOT_DIR/errors.log"
              echo "$output" >> "$ROOT_DIR/errors.log"
              echo "===========================================" >> "$ROOT_DIR/errors.log"
              echo "" >> errors.log
            fi
            
            # Go back to root directory
            cd "$ROOT_DIR"
            echo "üìÇ Returned to directory: $(pwd)"
            echo ""
            echo "üîÑ ===== COMPLETED POLICY: $policy ====="
            echo ""
            
          done <<< "${{ steps.changed-policies.outputs.policies }}"
          
          echo "==============================================="
          echo "üîç VULNERABILITY CHECK COMPLETED"
          echo "==============================================="
          
          # Check if any vulnerabilities were found and fail the job if so
          if [[ -f "$ROOT_DIR/errors.log" ]] && grep -q "Vulnerabilities found in policy\|govulncheck failed for policy" "$ROOT_DIR/errors.log"; then
            echo "‚ùå Vulnerability checks failed - see errors above"
            exit 1
          fi

      # ------------------------------------------------------------
      # Build check
      # ------------------------------------------------------------
      - name: Build policies
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_BUILD == 'true'
        run: |
          echo "Building changed policies..."
          
          while IFS= read -r policy; do
            [[ -z "$policy" ]] && continue
            
            echo "Building policy: $policy"
            if output=$(cd "policies/$policy" && go build -v ./... 2>&1); then
              echo "‚úÖ Build passed for policy: $policy"
            else
              echo "‚ùå Build failed for policy: $policy" >> errors.log
              echo "$output" >> errors.log
              echo "" >> errors.log
            fi
          done <<< "${{ steps.changed-policies.outputs.policies }}"

      # ------------------------------------------------------------
      # Test policies
      # ------------------------------------------------------------
      - name: Test policies
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_TESTS == 'true'
        run: |
          echo "Testing changed policies..."
          
          while IFS= read -r policy; do
            [[ -z "$policy" ]] && continue
            
            echo "Testing policy: $policy"
            if output=$(cd "policies/$policy" && go test -v -race -timeout=5m ./... 2>&1); then
              echo "‚úÖ Tests passed for policy: $policy"
            else
              echo "‚ùå Tests failed for policy: $policy" >> errors.log
              echo "$output" >> errors.log
              echo "" >> errors.log
            fi
          done <<< "${{ steps.changed-policies.outputs.policies }}"

      # ------------------------------------------------------------
      # Validate policy structure
      # ------------------------------------------------------------
      - name: Validate policy structure
        if: steps.changed-policies.outputs.has_changes == 'true' && env.RUN_POLICY_VALIDATION == 'true'
        run: |
          echo "Validating policy structure..."
          
          while IFS= read -r policy; do
            [[ -z "$policy" ]] && continue
            
            echo "Validating policy: $policy"
            
            POLICY_DIR="policies/$policy"
            POLICY_ERRORS=""
            
            # Check required files exist
            for file in go.mod policy-definition.yaml; do
              if [[ ! -f "$POLICY_DIR/$file" ]]; then
                POLICY_ERRORS+="‚ùå Missing required file: $POLICY_DIR/$file\n"
              fi
            done
            
            # Check at least one .go file exists
            if ! find "$POLICY_DIR" -name "*.go" -type f | grep -q .; then
              POLICY_ERRORS+="‚ùå No .go files found in $POLICY_DIR\n"
            fi
            
            # Validate go.mod module path
            if [[ -f "$POLICY_DIR/go.mod" ]]; then
              MODULE_PATH=$(grep '^module ' "$POLICY_DIR/go.mod" | awk '{print $2}')
              EXPECTED="github.com/DakshithaS/gateway-controllers/policies/$policy"
              
              if [[ "$MODULE_PATH" != "$EXPECTED"* ]]; then
                POLICY_ERRORS+="‚ùå Invalid module path in $POLICY_DIR/go.mod\n"
                POLICY_ERRORS+="   Expected: $EXPECTED\n"
                POLICY_ERRORS+="   Got: $MODULE_PATH\n"
              fi
            fi
            
            if [[ -n "$POLICY_ERRORS" ]]; then
              echo "‚ùå Policy structure validation failed for: $policy" >> errors.log
              echo "$POLICY_ERRORS" >> errors.log
              echo "" >> errors.log
            else
              echo "‚úÖ Policy structure validation passed for: $policy"
            fi
            
          done <<< "${{ steps.changed-policies.outputs.policies }}"

      # ------------------------------------------------------------
      # Check for errors and fail
      # ------------------------------------------------------------
      - name: Fail if errors found
        if: steps.changed-policies.outputs.has_changes == 'true'
        run: |
          if [[ -f errors.log ]]; then
            cat errors.log
            exit 1
          fi

      # ------------------------------------------------------------
      # Summary
      # ------------------------------------------------------------
      - name: Generate summary
        if: always()
        run: |
          if [[ "${{ steps.changed-policies.outputs.has_changes }}" == "true" ]]; then
            echo "## üîç PR Checks Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Changed policies:**" >> $GITHUB_STEP_SUMMARY
            
            while IFS= read -r policy; do
              [[ -z "$policy" ]] && continue
              echo "- \`$policy\`" >> $GITHUB_STEP_SUMMARY
            done <<< "${{ steps.changed-policies.outputs.policies }}"
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Checks performed:**" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Go formatting" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Import formatting" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Go vet" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Static analysis (staticcheck)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Vulnerability check (govulncheck)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Build verification" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Test execution (with race detection)" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Policy structure validation" >> $GITHUB_STEP_SUMMARY
          else
            echo "## üîç PR Checks Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No policy changes detected in this PR." >> $GITHUB_STEP_SUMMARY
          fi

      # ------------------------------------------------------------
      # Comment on PR if failed
      # ------------------------------------------------------------
      - name: Comment on PR if checks failed
        if: failure() && steps.changed-policies.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let errorsContent = '';
            
            if (fs.existsSync('errors.log')) {
              const rawErrors = fs.readFileSync('errors.log', 'utf8');
              
              // Simple approach: organize by type
              const vulnerabilityPolicies = new Set();
              const staticcheckPolicies = new Map();
              
              const lines = rawErrors.split('\n');
              let currentPolicy = '';
              let currentType = '';
              let collectingStatic = false;
              
              for (const line of lines) {
                if (line.includes('‚ùå Vulnerabilities found in policy:')) {
                  currentPolicy = line.match(/policy: (.+)$/)?.[1];
                  if (currentPolicy) vulnerabilityPolicies.add(currentPolicy);
                  currentType = 'vuln';
                  collectingStatic = false;
                } else if (line.includes('‚ùå staticcheck failed for policy:')) {
                  currentPolicy = line.match(/policy: (.+)$/)?.[1];
                  currentType = 'static';
                  collectingStatic = false;
                } else if (line.includes('üîç STATICCHECK ERRORS:')) {
                  currentType = 'static';
                  collectingStatic = true;
                } else if (collectingStatic && line.trim() && !line.includes('‚ùå') && !line.includes('üîç')) {
                  if (!staticcheckPolicies.has(currentPolicy)) {
                    staticcheckPolicies.set(currentPolicy, []);
                  }
                  staticcheckPolicies.get(currentPolicy).push(line);
                } else if (line.includes('Error:') && currentType === 'static' && currentPolicy) {
                  if (!staticcheckPolicies.has(currentPolicy)) {
                    staticcheckPolicies.set(currentPolicy, []);
                  }
                  staticcheckPolicies.get(currentPolicy).push(line.replace('Error: ', ''));
                }
              }
              
              // Build clean output
              if (vulnerabilityPolicies.size > 0) {
                errorsContent += '### üî¥ Security Vulnerabilities\n\n';
                vulnerabilityPolicies.forEach(policy => {
                  errorsContent += `**${policy}**\n`;
                  errorsContent += '- üî¥ 2 vulnerabilities found (Go standard library)\n';
                  errorsContent += '- üîß Fix: Upgrade to Go 1.25.5 or later\n\n';
                });
              }
              
              if (staticcheckPolicies.size > 0) {
                errorsContent += '### üîç Code Quality Issues\n\n';
                staticcheckPolicies.forEach((errors, policy) => {
                  errorsContent += `**${policy}**\n`;
                  errors.forEach(error => {
                    errorsContent += `- \`${error}\`\n`;
                  });
                  errorsContent += '\n';
                });
              }
              
              if (!errorsContent) {
                errorsContent = rawErrors; // Fallback
              }
            } else {
              errorsContent = 'Unknown errors occurred.';
            }
            
            const serverUrl = '${{ github.server_url }}';
            const repo = '${{ github.repository }}';
            const runId = '${{ github.run_id }}';
            
            const body = "## ‚ùå PR Checks Failed\n\n" +
              errorsContent + "\n\n" +
              "### üõ†Ô∏è How to Fix\n\n" +
              "**For Security Vulnerabilities:**\n" +
              "- Upgrade to Go 1.25.5 or later to fix standard library vulnerabilities\n" +
              "- See [workflow run](" + serverUrl + "/" + repo + "/actions/runs/" + runId + ") for detailed vulnerability reports\n\n" +
              "**For Code Quality Issues:**\n" +
              "- Run `go fmt ./...` to fix formatting issues  \n" +
              "- Run `goimports -w .` to fix import issues\n" +
              "- Address staticcheck suggestions in the files mentioned above\n\n" +
              "---\n" +
              "*Automated checks include: formatting, imports, vet, staticcheck, vulnerability scanning, build verification, and tests.*";

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });